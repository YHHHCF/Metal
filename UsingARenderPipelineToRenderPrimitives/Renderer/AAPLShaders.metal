/*
See LICENSE folder for this sample’s licensing information.

Abstract:
Metal shaders used for this sample
*/

#include <metal_stdlib>

using namespace metal;

// Include header shared between this Metal shader code and C code executing Metal API commands.
#include "AAPLShaderTypes.h"

// Vertex shader outputs and fragment shader inputs
struct RasterizerData
{
    // The [[position]] attribute of this member indicates that this value
    // is the clip space position of the vertex when this structure is
    // returned from the vertex function.
    // Annotate the position field with the [[position]] attribute qualifier
    // to declare that this field holds the output position.
    float4 position [[position]];

    // Since this member does not have a special attribute, the rasterizer
    // interpolates its value with the values of the other triangle vertices
    // and then passes the interpolated value to the fragment shader for each
    // fragment in the triangle.
    float4 color;
//    float4 color [[flat]]; // use one vertex color
};

// declare vertex shader using vertex keyword
// Arg1: Metal calls this shader on each vertex using a unique vertex_id
// use [[vertex_id]] to know this id
// Arg2: an array of vertices
// Arg3: the size of view
// [[buffer(n)]] tell Metal explicitly which slot to use
// return an RasterizerData object
vertex RasterizerData
vertexShader(uint vertexID [[vertex_id]],
             constant AAPLVertex *vertices [[buffer(AAPLVertexInputIndexVertices)]],
             constant vector_uint2 *viewportSizePointer [[buffer(AAPLVertexInputIndexViewportSize)]])
{
    RasterizerData out;

    // Index into the array of positions to get the current vertex.
    // The positions are specified in pixel dimensions (i.e. a value of 100
    // is 100 pixels from the origin).
    float2 pixelSpacePosition = vertices[vertexID].position.xy;

    // Get the viewport size and cast to float.
    vector_float2 viewportSize = vector_float2(*viewportSizePointer);

    // To convert from positions in pixel space to positions in clip-space,
    // divide the pixel coordinates by half the size of the viewport.
    out.position = vector_float4(0.0, 0.0, 0.0, 1.0);
    out.position.xy = pixelSpacePosition / (viewportSize / 2.0);

    // Pass the input color directly to the rasterizer.
    out.color = vertices[vertexID].color;

    return out;
}

// The rasterizer determines which pixels of the render target
// are covered by the primitive. Only fragments whose pixel centers
// are inside the triangle are rendered.

// A fragment function processes incoming information from the
// rasterizer for a single position and calculates output values
// for each of the render targets.

// Arg1: rasterizer output data: RasterizerData
// Add the [[stage_in]] attribute qualifier to indicate that
// this argument is generated by the rasterizer.
fragment float4 fragmentShader(RasterizerData in [[stage_in]])
{
    // If your fragment function writes to multiple render targets,
    // it must declare a struct with fields for each render target.
    // Because this sample only has a single render target, you
    // specify a floating-point vector directly as the function’s output.
    // This output is the color to be written to the render target.
    
    // Defualut behavior: the rasterization stage calculates its color
    // argument as a blend of the colors at the triangle’s vertices.
    return in.color;
    
//    return vector_float4(1.0, 0.0, 0.0, 1.0); // can modify to render a red triangle
}

